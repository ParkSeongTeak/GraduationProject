1. 과제 개요
 이번 과제에서는 상용 게임 엔진인 Unity를 사용하여 여러 명의 플레이어가 함께 플레이할 수 있는 온라인 게임을 개발하는 것을 목표로 합니다. 
 우선 플레이어는 회원가입을 진행합니다. 비밀번호는 해시 함수를 거친 후 저장합니다. 플레이어 데이터는 이메일을 키로 하는 DB에 저장합니다. 
 어몽어스 등의 게임에서와 같이, 플레이어는 대기실을 생성하거나, 이미 존재하는 대기실에 참가할 수 있습니다. 한 대기실에는 최대 4명의 플레이어가 참가할 수 있습니다. 방을 생성한 플레이어가 게임을 시작할 시, 각 플레이어는 캐릭터를 선택합니다. 캐릭터는 전사, 화승총 병, 마법사, 사제로 4가지가 있으며, 중복 선택이 가능합니다. 캐릭터마다 서로 다른 기본 공격과 스킬을 1개씩 가지고 있습니다. 일정 시간이 지날 때마다, 라운드가 진행되며, 정해진 양의 몬스터가 소환됩니다. 몬스터는 지도 중앙의 코어를 향해 다가오며, 코어만을 공격합니다. 플레이어는 몬스터를 처치하여 코어를 지켜야 합니다.
 몬스터를 처치할 때마다, 모든 플레이어는 재화를 얻습니다. 플레이어는 재화를 사용하여 유물 뽑기를 수행할 수 있습니다. 유물은 플레이어당 최대 8개를 보유할 수 있으며, 그 이상 가질 시 하나를 제거해야 합니다. 유물은 플레이어의 공격력, 공격 범위 등 이로운 효과를 줍니다. 유물은 등급이 있으며, 플레이어는 높은 등급의 유물을 모아 캐릭터의 능력치를 높여야 합니다. 이 재화와 유물은 DB에 저장되는 것이 아니라, 매 판 초기화됩니다. 최종 라운드까지 지도 중앙의 코어를 지키면서, 모든 몬스터를 처치하면 게임을 클리어합니다. 
 게임의 서버는 C# 언어를 기반으로 아마존의 AWS EC2 Instance를 사용하여 구현됩니다. 우리는 TCP 소켓 네트워크 통신을 이용하여 게임 클라이언트와 서버 간의 통신을 구현할 것이며, 직접 정의한 패킷을 사용하여 데이터 전송을 처리할 것입니다. 게임 내에서 발생하는 플레이어의 조작, 몬스터의 움직임 등 이벤트들은 서버에서 처리되어 결과가 클라이언트에게 전달됩니다. 또한, 게임 서버는 동시 접속자 100명 이하의 사용자들의 동시 접속에 대응할 수 있을 것을 최소한의 조건으로 개발할 것입니다.

2. 필요성 및 동기
 게임에서 가장 중요한 요소는 재미라고 생각하기에, 저희의 가장 큰 목표는 재미있는 게임을 만드는 것입니다. 실현 가능성 또한 고려하여, 재미있으면서도 가볍게 즐길 수 있는 게임을 목표로 잡았습니다. 이를 위해 비슷한 요구 사항을 가진 게임을 탐색했습니다.
 첫 번째 게임은 메이플 운빨 디펜스(이하 메운디)입니다. 메운디는 스타크래프트의 유저 제작 컨텐츠입니다. 이 게임은 플레이어가 할 수 있는 상호작용은 적지만, 캐릭터 뽑기라는 확률적 요소를 크게 활용하여 스타크래프트라는 게임이 재조명될 정도로 인기를 얻었습니다.
 그래서 저희는 메운디에서 아이디어를 차용하여 플레이어의 상호작용은 적지만 확률적 요소를 통해 게임적 재미를 챙길 수 있는 게임을 구상하기로 방향성을 잡았습니다. 메운디와 차별점을 두어, 플레이어 한 명이 하나의 캐릭터만을 조작하는 시스템으로 설정하였습니다. 따라서 메운디 재미의 원천인 뽑기를 캐릭터 뽑기에 적용하는 것이 아니라 다른 방식이 필요했습니다.
 이에 또 참고한 게임은 아이작의 번제입니다. 아이작의 번제는 아이템에 확률적 요소를 적용한 게임입니다. 획득하는 아이템에 따라 플레이 스타일이 크게 달라지기 때문에, 같은 패턴의 적이더라도 아이템에 따라 매판 신선한 느낌을 받을 수 있습니다. 
 따라서 두 가지 게임을 차용하여, 개발 가성비가 높은 디펜스를 기초로 하되, 아이템 뽑기로 신선한 재미를 얻을 수 있는 게임으로 방향성을 잡았습니다. 5~10종의 아이템을 기획하고, 하나의 아이템에서 등급을 세분화하여 상위 등급의 아이템에 출현 확률을 극단적으로 낮추었습니다. 

3. 요소 기술
 구현을 위해서 갖추어야 할 기술은 다음과 같습니다.
 첫째, Unity Engine 및 Unity의 스크립트 언어인 C#에 대한 지식입니다. 플레이어들이 직접 설치할 모바일 앱인 게임 클라이언트를 Unity로 구현합니다. 실제 게임 플레이, 플레이어와의 상호작용, UI 등의 요소를 구현할 기술이 필요합니다.
 둘째, AWS EC2 Instance 및 서버 구현을 위한 C# 지식입니다. 실제 컴퓨터를 게임 서버로 돌리기에는 많은 한계가 있습니다. 따라서 아마존에서 제공하는 가상 머신 인스턴스를 서버로 사용합니다. 서버 프로그램은 클라이언트와 마찬가지로 C#으로 구현합니다.
 셋째, Socket 클래스를 사용하는 TCP 통신 지식입니다. 클라이언트와 서버간의 통신은 모두 Socket을 사용하여 구현합니다. 서버는 리슨 소켓이 존재하며 클라이언트의 연결 요청이 올 때마다 그에 대응하는 Socket이 생성됩니다. 서버에서는 방 입장, 게임 내에서의 브로드캐스팅 등 클라이언트 관련 처리를 Socket으로 관리합니다. 
 넷째, 패킷 설계 능력입니다. 클라이언트-서버 간에는 매우 잦고 많은 데이터 통신이 요구됩니다. 또한 방 안의 클라이언트끼리는 서로 직접 통신하지 않기 때문에, 서버는 많은 브로드캐스팅을 수행합니다. 따라서 효과적으로 데이터를 전송하는 방법이 필요합니다. 따라서 미리 통신에 사용할 패킷의 형태를 정해둔 뒤, 그러한 형태로만 데이터 전송을 수행합니다. 한 패킷의 크기는 최대한 작은 사이즈를 목표로 합니다.
 
 과거에 다양한 게임을 출시하였으며, 이를 통해 클라이언트에서 기본적인 back Bone 구조는 같은 형태를 가짐을 알았습니다. 따라서 GameManager의 Singleton 구조, SoundManager, UIHandler 등의 모든 게임이 공통으로 갖는 back bone은 재사용합니다.
 이번 프로젝트에서의 중점은 기존의 서비스를 사용하지 않고, Socket을 사용하여 직접적인 네트워크 통신을 구현하는 것입니다. Unity에는 Photon Unity Network(PUN), Mirror 등 통신을 위한 패키지가 있습니다. PUN은 TCP 기반, Mirror는 Reliable UDP를 기반으로 제작된 패키지입니다. PUN은 photon에서 백엔드 서버를 제공하여 패키지 사용자에게 간편한 사용을 제공합니다. 하지만 대규모의 개발을 진행할 시 과금을 해야 하는 구조를 갖추고 있습니다. 따라서 게임사에서는 자체 서버를 운용하는 것이 대부분입니다. 패키지 없이 진행한 통신 구현 경험을 쌓기 위하여 Socket으로 직접 구현하기로 결정하였습니다.

4. 상세 내용
  4.1 요구 사항
 구현이 필요한 요구사항은 다음과 같습니다.
 첫째, 회원가입 및 로그인 시스템입니다. 회원가입/로그인 시 클라이언트는 자신의 이메일과 비밀번호를 서버에게 전송합니다. 이 때, 비밀번호는 SHA-256 방식으로 암호화합니다. 서버에서는 이메일을 key 값으로 하는 DB를 운용하여 플레이어 계정을 관리합니다. 회원가입 시 insert를 수행하고 등록 성공 여부를 클라이언트에게 전송합니다. 로그인 시에는 select를 통해 조회하여 인증 성공 여부를 클라이언트에 전송합니다. 
 둘째, 4인 협동을 위한 방 시스템입니다. 서버에서는 방을 방 이름을 key로 하는 dictionary로 관리합니다. 플레이어는 방 생성 시 방 이름을 입력합니다. 방 이름이 겹친다면 서버에서 거부하여 생성에 실패합니다. 방 생성에 성공 시 dinctionary에 추가합니다. 다른 플레이어들은 방 이름을 입력하여 입장할 수 있습니다. 방을 생성한 사람은 빠른 입장 설정을 할 수 있습니다. 빠른 입장 설정 시, dictionary와 별개로 관리하는 빠른 입장 Queue에 등록합니다. 서버는 빠른 입장 요청을 받을 때마다, queue의 방과 연결해줍니다.
 셋째, 방 단위 통신 관리입니다. 게임을 시작하면 각각의 클라이언트는 클래스 선택, 플레이어 이동, 공격 등 모든 액션에 대해 서버에 패킷을 전송합니다. 서버는 받은 패킷에 따라 데이터를 처리하며, 처리한 결과를 다른 클라이언트들에게 브로드캐스팅합니다. 몬스터에 관련된 연산은 서버에서 수행하며, 마찬가지로 수행 결과를 클라이언트들에게 브로드캐스팅합니다. 이를 통해 클라이언트 간 수행 결과가 다를 수 있다는 문제를 막습니다.
 넷째, 플레이어와의 상호작용 기능입니다. 캐릭터의 조작, 게임 입장, 아이템 뽑기 등 모든 행동은 버튼과 조이스틱을 사용합니다. 몬스터 처치 데이터를 서버로부터 받을 시 플레이어는 재화를 얻습니다. 플레이어는 언제든 뽑기 버튼을 눌러 유물을 뽑을 수 있습니다. 유물의 보유 상태, 신규 유물, 유물에 따른 능력치 증가 등은 서버가 관여하지 않고 클라이언트 내에서 처리합니다.

  4.2 시스템 설계 (합성 및 분석)
 현재까지의 클라이언트의 클래스 구조는 아래 그림과 같습니다.

[그림 1] 클라이언트 클래스 구조도

 기본적으로 게임 전체를 관장하는 GameManager 클래스가 있습니다. GameManager는 하나의 인스턴스만을 갖는 Singleton 패턴을 가지며, 어느 클래스에서나 접근할 수 있습니다. GameManager는 Sound, Network 등 각 목적에 맞는 Manager들의 인스턴스를 갖고 있습니다. 그 외 플레이어의 조작을 관리하는 PlayerController, 몬스터의 소환, 이동을 관리하는 MonsterSpawn, MonsterController 클래스가 있습니다.
 몬스터는 Pool을 사용하여 관리합니다. Game Object를 새롭게 생성/파괴하는 연산은 속도가 느립니다. 따라서 몬스터는 파괴하지 않고 보이지 않게 숨겨 두었다가, 새로 생성해야 할 때 숨겨둔 몬스터를 재사용하는 방식으로 연산 속도를 높입니다.
 Game Object 생성과 같이 sprite 등의 resource를 로드하는 작업도 속도가 느립니다. 따라서 resource를 로드할 때 resource의 경로를 key로 하는 dictionary에 캐싱합니다. 따라서 다음에 같은 resource를 로드할 시 빠르게 얻을 수 있습니다.
 사용자 인터페이스는 크게 조이스틱, 공격 및 스킬 버튼, 유물 및 뽑기로 나눌 수 있습니다. 조이스틱은 왼쪽 하단에 위치하며, 전방위 방향으로 조작할 수 있습니다. 공격 및 스킬 버튼은 오른쪽에 위치합니다. 버튼은 위, 아래로 구분되어있으며 기본 공격 버튼이 더 자주 사용되기에 더 큰 영역을 차지합니다.
  우측 상단에 본인이 획득한 유물이 아이콘으로 표시됩니다. 유물 뽑기 버튼은 아이콘 바로 아래에 위치합니다. 뽑기 버튼 클릭 시 뽑기 팝업 UI가 표시되며, 뽑기를 진행할 수 있습니다. 만약 최대 수량의 유물을 이미 가지고 있다면, 유물 버리기 팝업이 표시되고, 보유 유물과 현재 얻은 유물 중 하나를 선택하여 버립니다. 버리기 완료 시 팝업은 자동적으로 닫힙니다.
 서버에서 사용하는 주요 시스템은 다음과 같습니다.
 첫째, 몬스터 인덱싱 시스템입니다. 몬스터는 개체 구분을 위해 고유 번호를 갖습니다. 이 고유번호는 서버가 부여합니다. stack과 정수 카운터를 사용합니다. 카운터는 초기값이 0이며, 현재 가장 높은 몬스터 번호를 저장하고 있습니다. 몬스터를 새로 생성할 시, stack에서 번호를 뽑습니다. stack이 비어있을 시, 카운터의 번호를 사용하고 카운터를 1 증가시킵니다. 몬스터를 처치하면 stack에 push합니다. 이를 통해 효율적으로 몬스터 인덱스를 관리합니다.
 둘째, 빈 방 관리 시스템입니다. 연결이 끊기는 등 플레이어가 방에서 나가는 경우는 try-catch 구문을 통해 관리합니다. 이 때 방의 인원수를 계산하여 0인 방인 경우 dictionary에서 제거합니다. 만약의 경우를 대비하여 갈비지 콜렉터와 같이, 주기적으로 빈방 검사 함수를 호출합니다. 
 로그인 데이터 관리는 DBMS를 사용합니다. schema는 (email, password)입니다. 비밀번호는 클라이언트 단에서 SHA-256으로 암호화 후 전달하기 때문에, 서버에서는 각 유저의 비밀번호를 알 수 없습니다.

4.3 구현
 window 11 환경에서 개발을 진행합니다. 게임 엔진 Unity를 사용하며, 스크립트 언어로 C#을 사용합니다. 스크립트 에디터는 Visual Studio를 사용합니다. 서버는 C#, .Net Framework를 사용하여 개발합니다. 버전 관리 시스템으로 git, remote repository로 github를 사용합니다. 클라이언트는 안드로이드를 대상으로 빌드합니다.

  4.4 시험평가 
 중점적인 테스트 대상은 서버의 스트레스 테스트입니다. 100명의 사용자가 동시에 사용할 수 있는 지 테스트합니다.
 첫째, 로그인 대기열 스트레스 테스트입니다. 다수의 사용자가 동시에 로그인 시도를 진행하는 테스트를 수행하여 서버가 버틸 수 있는 지 검사합니다.
둘째, 게임 스트레스 테스트입니다. Dummy Client를 생성하여 다수의 방을 만듭니다. Dummy Client들은 무작위로 결정된 행동을 수행하여, 다수의 사용자가 동시에 게임을 실행할 수 있는 지 검사합니다.

5. 팀원의 기능 및 역할
 클라이언트의 코어가 되는 Manager는 두 팀원이 모여서 같이 개발합니다.
Playable에는 플레이어가 선택할 수 있는 직업의 구현, 기본 공격 및 스킬, 플레이어 조작을 포함합니다. 
Non-Playable에는 플레이어가 조작할 수 없는 요소인 몬스터의 이동, 공격, 보스를 포함합니다.
 서버의 작업은 Login System, Server Listener, Client Session, Packet Handler, Client Synchronization System, Packet Buffer로 나누었습니다. Server Listener는 클라이언트의 최초 Socket 연결을 관리합니다. Client Session은 패킷 통신을 관리합니다. Packet Handler는 패킷 종류에 따른 처리를 관리합니다. Client Synchronization System은 방 시스템 등 게임 플레이에서 진행되는 서버의 연산을 관리합니다. Packet Buffer는 패킷 통신 시의 버퍼를 관리합니다.
 역할 분배는 다음과 같습니다.
팀원 1 이우열 : Manager, Playable, UI ,PlayablePacketHandler, Login System, Client Session, Packet Buffer
팀원 2 박성택 :  Manager, NonePlayable, NonePlayablePacketHandler, Client Synchronization System, Server Listener
